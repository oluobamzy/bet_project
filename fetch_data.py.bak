import pandas as pd
import numpy as np
import logging
from pathlib import Path
import os
import joblib
from typing import Optional, List, Dict
from datetime import datetime, timedelta
from utils.cron.fetch_latest_data import fetch_fixtures, fetch_odds
from datetime import datetime, timedelta, timezone

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# --- Load historical match data
DATA_PATH = Path("utils/cron/data/processed/clean_matches.csv")

# Load feature list for consistency validation
FEATURE_LIST_PATH = os.path.join("models", "feature_list.pkl")
expected_features = None
if os.path.exists(FEATURE_LIST_PATH):
    try:
        with open(FEATURE_LIST_PATH, "rb") as f:
            feature_data = joblib.load(f)
            expected_features = feature_data.get("features", [])
            logging.info(f"‚úÖ Loaded expected feature list: {expected_features}")
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Failed to load feature list: {e}")

try:
    df_matches = pd.read_csv(DATA_PATH, parse_dates=["date"], low_memory=False)
    logging.info(f"‚úÖ Loaded {len(df_matches)} historical matches for reference")
except Exception as e:
    logging.error(f"‚ùå Failed to load match data: {e}")
    raise FileNotFoundError(f"‚ùå Failed to load match data: {e}")

# --- Helper Functions

def get_form(team_name: str, match_date: pd.Timestamp, window: int = 5) -> float:
    """Calculate win rate form for a team over last `window` matches before `match_date`."""
    recent_matches = df_matches[
        ((df_matches["home_team"] == team_name) | (df_matches["away_team"] == team_name)) &
        (df_matches["date"] < match_date)
    ].sort_values("date", ascending=False).head(window)

    if recent_matches.empty:
        logging.warning(f"‚ö†Ô∏è No recent matches found for {team_name}, using neutral form value")
        return 0.5  # fallback neutral value

    wins = 0
    for _, row in recent_matches.iterrows():
        if row["home_team"] == team_name and row["FTR"] == "H":
            wins += 1
        elif row["away_team"] == team_name and row["FTR"] == "A":
            wins += 1

    form = wins / len(recent_matches)
    logging.info(f"üìä Form for {team_name}: {form:.2f} ({wins}/{len(recent_matches)} wins)")
    return form


def get_h2h_rate(home_team: str, away_team: str, match_date: pd.Timestamp, window: int = 5) -> float:
    """Calculate head-to-head win rate of `home_team` against `away_team`."""
    h2h_matches = df_matches[
        (df_matches["h2h_key"] == str(frozenset([home_team, away_team]))) &
        (df_matches["date"] < match_date)
    ].sort_values("date", ascending=False).head(window)

    if h2h_matches.empty:
        logging.warning(f"‚ö†Ô∏è No H2H matches found between {home_team} and {away_team}, using neutral value")
        return 0.5  # fallback neutral value

    home_wins = 0
    for _, row in h2h_matches.iterrows():
        if row["home_team"] == home_team and row["FTR"] == "H":
            home_wins += 1
        elif row["away_team"] == home_team and row["FTR"] == "A":
            home_wins += 1

    h2h_rate = home_wins / len(h2h_matches)
    logging.info(f"ü§º H2H rate for {home_team} vs {away_team}: {h2h_rate:.2f} ({home_wins}/{len(h2h_matches)} wins)")
    return h2h_rate


def get_historical_odds(home_team: str, away_team: str, match_date: pd.Timestamp) -> Optional[Dict[str, float]]:
    """Get historical odds from dataset."""
    match = df_matches[
        (df_matches["home_team"] == home_team) &
        (df_matches["away_team"] == away_team) &
        (df_matches["date"] == match_date)
    ]

    if match.empty:
        return None

    row = match.iloc[0]
    return {
        "home_odds": row.get("home_odds", 2.0),
        "draw_odds": row.get("draw_odds", 3.0),
        "away_odds": row.get("away_odds", 2.0),
    }


def get_live_odds(home_team: str, away_team: str) -> Dict[str, float]:
    """Fetch live odds if available."""
    odds_data = fetch_odds()
    match = next(
        (event for event in odds_data if home_team in event.get('home_team', '') and away_team in event.get('away_team', '')),
        None
    )
    if match and match.get("bookmakers"):
        h2h = match["bookmakers"][0]["markets"][0]["outcomes"]
        home_odds = next((o["price"] for o in h2h if o["name"] == home_team), 2.5)
        draw_odds = next((o["price"] for o in h2h if o["name"].lower() == "draw"), 3.2)
        away_odds = next((o["price"] for o in h2h if o["name"] == away_team), 2.8)
        logging.info(f"üìà Live odds for {home_team} vs {away_team}: H={home_odds}, D={draw_odds}, A={away_odds}")
    else:
        home_odds, draw_odds, away_odds = 2.5, 3.2, 2.8  # fallback defaults
        logging.warning(f"‚ö†Ô∏è No live odds found for {home_team} vs {away_team}, using default values")

    return {
        "home_odds": home_odds,
        "draw_odds": draw_odds,
        "away_odds": away_odds,
    }

# --- MAIN function to build input features
def fetch_fixture_inputs(league_name: str = "EPL", for_tomorrow: bool = False) -> List[Dict]:
    """
    Fetch and construct input features for upcoming fixtures in the specified league.
    """
    fixtures = fetch_fixtures()
    inputs = []

    logging.info(f"üîç Fetching fixtures for {league_name}, for_tomorrow={for_tomorrow}")
    logging.info(f"üìÜ Found {len(fixtures)} total fixtures to process")

    # Get the current date and tomorrow's date, considering time zones
    now = datetime.now(timezone.utc)  # Use timezone-aware datetime in UTC
    today_date = now.date()
    tomorrow_date = (now + timedelta(days=1)).date()
    
    target_date = tomorrow_date if for_tomorrow else today_date
    logging.info(f"üìÖ Target date: {target_date}")

    # Define expected feature order for validation
    expected_feature_order = [
        "home_odds", "away_odds", "draw_odds", 
        "home_form", "away_form", "h2h_win_rate"
    ] if expected_features is None else expected_features
    
    filtered_fixtures = 0
    for fx in fixtures:        try:
            # Filter by league name to avoid processing unnecessary fixtures
            league_name_in_api = fx.get('league', {}).get('name', '')
            league_id = fx.get('league', {}).get('id', 0)
            
            # Define mappings between API league IDs and our league codes
            league_id_mappings = {
                39: "EPL",       # Premier League (England)
                140: "LaLiga",   # La Liga (Spain)
                135: "SerieA",   # Serie A (Italy)
                78: "Bundesliga", # Bundesliga (Germany)
                61: "Ligue1",    # Ligue 1 (France)
                # Add more mappings as needed
            }
            
            # Check if this fixture matches our requested league
            if (league_name != league_id_mappings.get(league_id) and 
                league_name not in league_name_in_api):
                logging.debug(f"Skipping fixture in league: {league_name_in_api} (ID: {league_id}), looking for {league_name}")
                continue
            
            filtered_fixtures += 1
            home = fx['teams']['home']['name']
            away = fx['teams']['away']['name']
            match_datetime = pd.to_datetime(fx['fixture']['date']).tz_convert('UTC')  # Convert to UTC
            match_date = match_datetime.date()
            
            logging.info(f"‚öΩ Processing fixture: {home} vs {away} on {match_date}")

            # Filter by date
            if match_date != target_date:
                logging.info(f"üóìÔ∏è Fixture date {match_date} does not match target date {target_date}, skipping")
                continue

            # Fetch statistics for both teams
            try:
                home_form = get_form(home, match_datetime) or 0.5
                away_form = get_form(away, match_datetime) or 0.5
                h2h = get_h2h_rate(home, away, match_datetime) or 0.5
                odds = get_live_odds(home, away) or {}
            except Exception as stats_err:
                logging.error(f"‚ùå Error fetching stats for {home} vs {away}: {stats_err}")
                continue

            # Construct feature vector with default values if missing
            features = [
                odds.get("home_odds", 2.0),
                odds.get("away_odds", 2.0),
                odds.get("draw_odds", 3.0),
                home_form,
                away_form,
                h2h
            ]

            # Check for feature size correctness
            if len(features) != len(expected_feature_order):
                logging.error(f"‚ö†Ô∏è Feature size mismatch for {home} vs {away}. Expected {len(expected_feature_order)}, got {len(features)}.")
                continue

            # Log feature values
            feature_dict = dict(zip(expected_feature_order, features))
            logging.info(f"üìä Features for {home} vs {away}:")
            for name, value in feature_dict.items():
                logging.info(f"  ‚Ä¢ {name}: {value:.3f}")

            # Append the valid input data
            inputs.append({
                "home": home,
                "away": away,
                "date": str(match_date),
                "features": features
            })
            logging.info(f"‚úÖ Successfully generated prediction inputs for {home} vs {away}")

        except KeyError as ke:
            logging.error(f"‚ö†Ô∏è Skipped fixture due to missing key: {ke}")
        except Exception as e:
            logging.error(f"‚ùå Error processing fixture {fx.get('fixture', {}).get('id', 'Unknown')}: {e}")

    logging.info(f"‚úÖ Successfully processed {filtered_fixtures} fixtures for {league_name}")
    logging.info(f"‚úÖ Generated prediction inputs for {len(inputs)} matches")
    return inputs


