from typing import List, Dict, Optional, Union, Any
import logging
import pandas as pd
import json
import os
from pathlib import Path
from datetime import datetime, timedelta, timezone
import requests

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Define expected features order for model consistency
expected_features = None

def fetch_fixtures() -> List[Dict]:
    """
    Fetch fixtures from cache files.
    """
    # Look for fixture data in cache first
    cache_dir = Path("cache")
    fixtures = []
    
    # Define mappings between API league IDs and our league codes
    league_id_mappings = {
        39: "EPL",       # Premier League (England)
        140: "LaLiga",   # La Liga (Spain)
        135: "SerieA",   # Serie A (Italy)
        78: "Bundesliga", # Bundesliga (Germany)
        61: "Ligue1",    # Ligue 1 (France)
        94: "PrimeiraLiga", # Primeira Liga (Portugal)
        88: "Eredivisie", # Eredivisie (Netherlands)
        144: "ProLeague", # Pro League (Belgium)
        179: "SPL",      # Scottish Premier League
        203: "SuperLig", # Super Lig (Turkey)
        218: "BundesligaAT", # Austrian Bundesliga
        222: "SuperLeagueCH", # Swiss Super League
        197: "Superliga", # Danish Superliga
        106: "Eliteserien", # Norwegian Eliteserien
        121: "Allsvenskan", # Swedish Allsvenskan
        332: "UPL",      # Ukrainian Premier League
        200: "SuperLeagueGR", # Greek Super League
        233: "FortunaLiga", # Czech Fortuna Liga
        241: "HNL",      # Croatian HNL
        237: "SuperLigaRS", # Serbian Super Liga
        205: "Ekstraklasa", # Polish Ekstraklasa
        208: "PremierLeagueIL" # Israeli Premier League
    }
    
    # Try to load fixtures from cache files
    for fixture_file in cache_dir.glob("fixtures_*.json"):
        try:
            with open(fixture_file, 'r') as f:
                data = json.load(f)
                response_fixtures = data.get('response', [])
                fixtures.extend(response_fixtures)
        except Exception as e:
            logging.error(f"‚ùå Error loading fixture file {fixture_file}: {e}")
    
    logging.info(f"üìä Loaded {len(fixtures)} fixtures from cache")
    return fixtures

def get_form(team: str, match_date: datetime) -> float:
    """
    Calculate team form based on recent performances.
    For the prototype, return a random value.
    """
    # Placeholder implementation - should be based on actual historical data
    import random
    return random.uniform(0.3, 0.9)

def get_h2h_rate(home_team: str, away_team: str, match_date: datetime) -> float:
    """
    Calculate head-to-head win rate for the home team against the away team.
    For the prototype, return a random value.
    """
    # Placeholder implementation - should be based on actual head-to-head history
    import random
    return random.uniform(0.2, 0.8)

def get_live_odds(home_team: str, away_team: str) -> Dict:
    """
    Get latest betting odds for the specified match.
    If not available, estimate based on rankings/form.
    """
    # Try to load odds from cache
    odds_file = Path("data/live/latest_odds.json")
    if odds_file.exists():
        try:
            with open(odds_file, 'r') as f:
                all_odds_data = json.load(f).get("data", {})
            
            # Look for the match in all leagues
            for league_odds in all_odds_data.values():
                for match in league_odds:
                    home = match.get("home_team", "")
                    away = match.get("away_team", "")
                    
                    # Simple name matching - should be improved with fuzzy matching
                    if (home_team.lower() in home.lower() or home.lower() in home_team.lower()) and \
                       (away_team.lower() in away.lower() or away.lower() in away_team.lower()):
                        home_odds = match.get("bookmakers", [{}])[0].get("markets", [{}])[0].get("outcomes", [{}])[0].get("price", 2.0)
                        away_odds = match.get("bookmakers", [{}])[0].get("markets", [{}])[0].get("outcomes", [{}])[1].get("price", 3.0)
                        draw_odds = match.get("bookmakers", [{}])[0].get("markets", [{}])[0].get("outcomes", [{}, {}, {}])[2].get("price", 3.5)
                        
                        return {
                            "home_odds": home_odds,
                            "away_odds": away_odds,
                            "draw_odds": draw_odds,
                        }
        except Exception as e:
            logging.error(f"‚ùå Error reading odds file: {e}")
    
    # Return estimated odds if live odds not found
    home_odds = 2.0  # Placeholder
    away_odds = 3.5  # Placeholder
    draw_odds = 3.0  # Placeholder
    
    return {
        "home_odds": home_odds,
        "draw_odds": draw_odds,
        "away_odds": away_odds,
    }

# --- MAIN function to build input features
def fetch_fixture_inputs(league_name: str = "EPL", for_tomorrow: bool = False) -> List[Dict]:
    """
    Fetch and construct input features for upcoming fixtures in the specified league.
    """
    fixtures = fetch_fixtures()
    inputs = []

    logging.info(f"üîç Fetching fixtures for {league_name}, for_tomorrow={for_tomorrow}")
    logging.info(f"üìÜ Found {len(fixtures)} total fixtures to process")

    # Get the current date and tomorrow's date, considering time zones
    now = datetime.now(timezone.utc)  # Use timezone-aware datetime in UTC
    today_date = now.date()
    tomorrow_date = (now + timedelta(days=1)).date()
    
    target_date = tomorrow_date if for_tomorrow else today_date
    logging.info(f"üìÖ Target date: {target_date}")

    # Define expected feature order for validation
    expected_feature_order = [
        "home_odds", "away_odds", "draw_odds", 
        "home_form", "away_form", "h2h_win_rate"
    ] if expected_features is None else expected_features
    
    # Define mappings between API league IDs and our league codes
    league_id_mappings = {
        39: "EPL",       # Premier League (England)
        140: "LaLiga",   # La Liga (Spain)
        135: "SerieA",   # Serie A (Italy)
        78: "Bundesliga", # Bundesliga (Germany)
        61: "Ligue1",    # Ligue 1 (France)
        94: "PrimeiraLiga", # Primeira Liga (Portugal)
        88: "Eredivisie", # Eredivisie (Netherlands)
        144: "ProLeague", # Pro League (Belgium)
        # Add remaining leagues as needed
    }
    
    filtered_fixtures = 0
    for fx in fixtures:
        try:
            # Filter by league name to avoid processing unnecessary fixtures
            league_name_in_api = fx.get('league', {}).get('name', '')
            league_id = fx.get('league', {}).get('id', 0)
            
            # Check if this fixture matches our requested league
            matches_league = False
            if league_id in league_id_mappings and league_id_mappings[league_id] == league_name:
                matches_league = True
            elif league_name.lower() in league_name_in_api.lower():
                matches_league = True
                
            if not matches_league:
                continue
            
            filtered_fixtures += 1
            home = fx['teams']['home']['name']
            away = fx['teams']['away']['name']
            match_datetime = pd.to_datetime(fx['fixture']['date']).tz_convert('UTC')  # Convert to UTC
            match_date = match_datetime.date()
            
            logging.info(f"‚öΩ Processing fixture: {home} vs {away} on {match_date}")

            # Filter by date
            if match_date != target_date:
                logging.info(f"üóìÔ∏è Fixture date {match_date} does not match target date {target_date}, skipping")
                continue

            # Fetch statistics for both teams
            try:
                home_form = get_form(home, match_datetime) or 0.5
                away_form = get_form(away, match_datetime) or 0.5
                h2h = get_h2h_rate(home, away, match_datetime) or 0.5
                odds = get_live_odds(home, away) or {}
            except Exception as stats_err:
                logging.error(f"‚ùå Error fetching stats for {home} vs {away}: {stats_err}")
                continue

            # Construct feature vector with default values if missing
            features = [
                odds.get("home_odds", 2.0),
                odds.get("away_odds", 2.0),
                odds.get("draw_odds", 3.0),
                home_form,
                away_form,
                h2h
            ]

            # Check for feature size correctness
            if len(features) != len(expected_feature_order):
                logging.error(f"‚ö†Ô∏è Feature size mismatch for {home} vs {away}. Expected {len(expected_feature_order)}, got {len(features)}.")
                continue

            # Log feature values
            feature_log = ", ".join([f"{name}: {value:.3f}" for name, value in zip(expected_feature_order, features)])
            logging.info(f"‚úÖ Features for {home} vs {away}: [{feature_log}]")

            # Create a dictionary with all required information
            inputs.append({
                "home_team": home,
                "away_team": away,
                "match_date": match_datetime.isoformat(),
                "features": features,
                "league": league_name,
                "match_id": fx.get("fixture", {}).get("id", f"{home}-{away}-{match_date}")
            })

        except Exception as e:
            logging.error(f"‚ùå Error processing fixture: {e}")

    if not filtered_fixtures:
        logging.warning(f"‚ö†Ô∏è No fixtures found for league '{league_name}'")
    elif not inputs:
        logging.warning(f"‚ö†Ô∏è No valid fixtures found for league '{league_name}' on {target_date}")
    else:
        logging.info(f"‚úÖ Successfully processed {len(inputs)} fixtures for {league_name} on {target_date}")

    return inputs
