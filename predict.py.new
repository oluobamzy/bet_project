# predict.py

import os
import numpy as np
import pandas as pd
import joblib
import logging
from pathlib import Path
from fetch_data import fetch_fixture_inputs

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Dictionary to store loaded models
models = {}
feature_lists = {}

def load_model(league_name=None):
    """
    Load the appropriate model for the given league.
    If a league-specific model is available and the league is specified, use it.
    Otherwise, fall back to the general model.
    """
    models_folder = Path("models")
    
    # Determine model filename
    if league_name:
        # Try to use league-specific model
        model_path = models_folder / f"xgboost_model_{league_name}.pkl"
        feature_path = models_folder / f"feature_list_{league_name}.pkl"
        
        # If league model doesn't exist, use general model
        if not model_path.exists():
            logging.info(f"‚ö†Ô∏è No specific model for {league_name}, using general model")
            model_path = models_folder / "xgboost_model.pkl"
            feature_path = models_folder / "feature_list.pkl"
    else:
        # Use general model
        model_path = models_folder / "xgboost_model.pkl"
        feature_path = models_folder / "feature_list.pkl"
    
    # Check if model is already loaded
    model_key = league_name if league_name else "general"
    if model_key in models:
        logging.info(f"‚úÖ Using cached model for {model_key}")
        return models[model_key], feature_lists.get(model_key)
    
    # Load the model
    try:
        logging.info(f"üîÑ Loading model from {model_path}")
        if not model_path.exists():
            raise FileNotFoundError(f"Model file not found: {model_path}")
        
        model = joblib.load(model_path)
        logging.info(f"‚úÖ Model loaded successfully")
        
        # Load feature list if available
        feature_list = None
        if feature_path.exists():
            feature_list = joblib.load(feature_path)
            logging.info(f"‚úÖ Loaded feature list: {feature_list['features']}")
        
        # Cache the loaded model and feature list
        models[model_key] = model
        feature_lists[model_key] = feature_list
        
        return model, feature_list
        
    except Exception as e:
        logging.error(f"‚ùå Failed to load model for {model_key}: {e}")
        raise FileNotFoundError(f"‚ùå Failed to load model: {e}")

# Ensure at least the general model exists
try:
    general_model, general_features = load_model()
except FileNotFoundError:
    raise FileNotFoundError("‚ùå No model file (.pkl) found in models/ folder! Please train a model first.")

# Emoji and confidence indicators
OUTCOME_EMOJIS = ["üè†", "ü§ù", "üöÄ"]
CONFIDENCE_INDICATORS = {
    "high": "‚≠ê‚≠ê‚≠ê",  # 75%+
    "medium": "‚≠ê‚≠ê",   # 60-75%
    "low": "‚≠ê",      # <60%
}

# --- Predict upcoming fixtures
def predict_bet(league: str = "EPL") -> str:
    """Predict matches scheduled for TODAY for a given league."""
    fixtures = fetch_fixture_inputs(league_name=league, for_tomorrow=False)

    if not fixtures:
        return "‚ùå No fixtures found for today."
        
    # Load appropriate model for this league
    try:
        current_model, _ = load_model(league)
    except Exception as e:
        logging.error(f"‚ùå Failed to load model for {league}: {e}")
        return f"‚ùå Error loading prediction model: {str(e)}"

    results = []
    for fixture in fixtures:
        home = fixture["home_team"]
        away = fixture["away_team"]
        features = fixture["features"]

        try:
            input_array = np.array(features).reshape(1, -1)
            
            # Get prediction probabilities
            prediction_probs = current_model.predict_proba(input_array)[0]
            prediction_class = current_model.predict(input_array)[0]
            
            # Determine outcome emoji (home win, draw, away win)
            outcome_emoji = OUTCOME_EMOJIS[prediction_class]
            
            # Determine confidence level based on prediction probability
            confidence = prediction_probs[prediction_class]
            if confidence >= 0.75:
                confidence_indicator = CONFIDENCE_INDICATORS["high"]
            elif confidence >= 0.60:
                confidence_indicator = CONFIDENCE_INDICATORS["medium"]
            else:
                confidence_indicator = CONFIDENCE_INDICATORS["low"]
            
            # Format result
            result = {
                "home": home,
                "away": away,
                "prediction_class": int(prediction_class),
                "confidence": confidence,
                "outcome_emoji": outcome_emoji,
                "confidence_indicator": confidence_indicator,
                "match_id": fixture.get("match_id", f"{home}-{away}")
            }
            results.append(result)
            
        except Exception as e:
            logging.error(f"Error predicting {home} vs {away}: {e}")
            continue
            
    if not results:
        return "‚ùå Could not make predictions for any fixtures."
    
    return results

def predict_bet_tomorrow(league_name: str = "EPL") -> str:
    """Predict matches scheduled for TOMORROW for a given league."""
    fixtures = fetch_fixture_inputs(league_name=league_name, for_tomorrow=True)

    if not fixtures:
        return "‚ùå No fixtures found for tomorrow."

    # Load appropriate model for this league
    try:
        current_model, _ = load_model(league_name)
    except Exception as e:
        logging.error(f"‚ùå Failed to load model for {league_name}: {e}")
        return f"‚ùå Error loading prediction model: {str(e)}"

    predictions = []
    for fixture in fixtures:
        home = fixture["home_team"]
        away = fixture["away_team"]
        features = fixture["features"]

        try:
            input_array = np.array(features).reshape(1, -1)
            
            # Get prediction probabilities
            prediction_probs = current_model.predict_proba(input_array)[0]
            prediction_class = current_model.predict(input_array)[0]
            
            # Determine outcome emoji (home win, draw, away win)
            outcome_emoji = OUTCOME_EMOJIS[prediction_class]
            
            # Determine confidence level based on prediction probability
            confidence = prediction_probs[prediction_class]
            if confidence >= 0.75:
                confidence_indicator = CONFIDENCE_INDICATORS["high"]
            elif confidence >= 0.60:
                confidence_indicator = CONFIDENCE_INDICATORS["medium"]
            else:
                confidence_indicator = CONFIDENCE_INDICATORS["low"]
            
            # Format result
            prediction = {
                "home": home,
                "away": away,
                "prediction_class": int(prediction_class),
                "confidence": confidence,
                "outcome_emoji": outcome_emoji,
                "confidence_indicator": confidence_indicator,
                "match_id": fixture.get("match_id", f"{home}-{away}")
            }
            predictions.append(prediction)
            
        except Exception as e:
            logging.error(f"Error predicting {home} vs {away}: {e}")
            continue
            
    if not predictions:
        return "‚ùå Could not make predictions for any fixtures."
    
    return predictions

# --- Utility functions for formatting predictions
def format_predictions_for_discord(predictions, is_tomorrow=False):
    """Format predictions as a Discord message."""
    if isinstance(predictions, str):
        return predictions  # Return error message
    
    time_str = "üîÆ TOMORROW'S" if is_tomorrow else "‚öΩ TODAY'S"
    outcome_text = {0: "Home Win", 1: "Draw", 2: "Away Win"}
    
    # Header
    message = f"## {time_str} PREDICTIONS\n\n"
    
    # Sort predictions by confidence (highest first)
    sorted_predictions = sorted(predictions, key=lambda x: x['confidence'], reverse=True)
    
    # Format each match prediction
    for i, pred in enumerate(sorted_predictions):
        confidence_pct = int(pred['confidence'] * 100)
        message += f"**{pred['home']} vs {pred['away']}**\n"
        message += f"{pred['outcome_emoji']} **{outcome_text[pred['prediction_class']]}** "
        message += f"({confidence_pct}% confidence) {pred['confidence_indicator']}\n\n"
    
    message += "_These predictions are for entertainment purposes only. Please gamble responsibly._"
    return message

if __name__ == "__main__":
    # Test function
    print("Testing prediction for today's EPL matches:")
    results_today = predict_bet("EPL")
    if isinstance(results_today, str):
        print(results_today)
    else:
        for r in results_today:
            print(f"{r['home']} vs {r['away']}: {r['outcome_emoji']} ({int(r['confidence']*100)}% {r['confidence_indicator']})")
    
    print("\nTesting prediction for tomorrow's EPL matches:")
    results_tomorrow = predict_bet_tomorrow("EPL")
    if isinstance(results_tomorrow, str):
        print(results_tomorrow)
    else:
        for r in results_tomorrow:
            print(f"{r['home']} vs {r['away']}: {r['outcome_emoji']} ({int(r['confidence']*100)}% {r['confidence_indicator']})")
